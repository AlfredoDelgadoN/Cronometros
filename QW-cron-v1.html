<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cronómetro con Mapa</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body, #map { height: 100%; width: 100%; }
    #main-timer {
      position: absolute;
      top: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 2.5rem;
      font-weight: bold;
      color: black;
      text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
      z-index: 1000;
    }
    #lap-timer {
      position: absolute;
      bottom: 10px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 1.6rem;
      color: black;
      text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
      z-index: 1000;
    }
    .btn {
      position: absolute;
      bottom: 100px;
      padding: 12px 20px;
      font-size: 1.1rem;
      cursor: pointer;
      background: rgba(0,0,0,0.8);
      color: white;
      border: none;
      border-radius: 6px;
      z-index: 1000;
    }
    #start-btn { right: 20px; }
    #stop-btn { left: 20px; }
    #speed-btn, #pace-btn, #distance-btn {
      bottom: 240px;
      width: 100px;
      text-align: center;
    }
    #speed-btn { left: 20px; }
    #pace-btn { left: 50%; transform: translateX(-50%); }
    #distance-btn { right: 20px; }
      /* Contenedor flexible para métricas (abajo) */
    #metrics-bar {
        position: absolute;
        bottom: 20px;
        left: 12px;
        right: 12px;
        display: flex;
        justify-content: space-between;
        gap: 12px;
        z-index: 1000;
    }

    .metric-btn {      
        padding: 8px 12px;
        font-size: 1.3rem;        
        background: rgba(0, 0, 0, 0.65);
        color: white;
        border: none;
        border-radius: 6px;
        white-space: nowrap;
        z-index: 1000;
        min-width: 0; /* importante para que flex funcione bien en móviles */
        width: auto;
    }
    /* Ajuste para pantallas muy pequeñas */
    @media (max-width: 360px) {
        .metric-btn {
            font-size: 0.8rem;
            padding: 6px 10px;
        }
        #metrics-bar {
          gap: 10px;
          left: 10px;
          right: 10px;
        }
    }

    /* Botones de control (Iniciar / Detener) */
    #control-buttons {
        position: absolute;
        bottom: 80px;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-between;
        padding: 0 20px;
        z-index: 1000;
    }

    .control-btn {
        padding: 12px 20px;
        font-size: 1.1rem;
        cursor: pointer;
        background: rgba(0,0,0,0.6);
        color: white;
        border: none;
        border-radius: 6px;
    }
  
  </style>
</head>
<body>
    <div id="main-timer">00:00:00</div>

    <button id="measure-btn" class="metric-btn" style="
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      z-index: 1001;
    ">Medir</button>
    <div id="measure-display" style="
      position: absolute;
      top: 60px;
      right: 20px;
      background: rgba(255,255,255,0.85);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 1rem;
      color: black;
      font-weight: bold;
      z-index: 1001;
      min-width: 80px;
      text-align: center;
    ">-- m</div>

    <div id="lap-timer">00:00.0</div>

    <!-- Botones de control: Detener / Iniciar -->
    <div id="control-buttons">
    <button id="stop-btn" class="control-btn">Detener</button>
    <button id="start-btn" class="control-btn">Iniciar</button>
    </div>

    <!-- Barra de métricas: Velocidad, Ritmo, Distancia -->
    <div id="metrics-bar">
      <button id="speed-btn" class="metric-btn" style="position: absolute; bottom: 120px; left: 6px;">V: --</button>
      <button id="pace-btn" class="metric-btn" style="position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);">R: --</button>
      <button id="distance-btn" class="metric-btn" style="position: absolute; bottom: 120px; right: 6px;">K: 0.00</button>
    </div>

    <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ========== CONFIGURACIÓN GLOBAL ==========
    let map, marker, polyline;
    let watchId = null;
    let startTime = null;
    let lapStartTime = null;
    let isRunning = false;
    let laps = [];
    let positions = [];
    let totalDistance = 0;
    let lastPosition = null;
    let lapTimerInterval = null;
    let mainTimerInterval = null;
    let hasMarkedStart = false;
    let measureMode = false;
    let measureStartPos = null;
    let measureDistance = 0;

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // ========== INICIALIZAR MAPA ==========
    function initMap(lat, lng) {
      if (map) map.remove();
      map = L.map('map').setView([lat, lng], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);
      marker = L.marker([lat, lng]).addTo(map);
      polyline = L.polyline([], { color: 'red' }).addTo(map);
    }

    // ========== SONIDO BEEP ==========
    function beep() {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.value = 880;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
    }

    // ========== FORMATO DE TIEMPO ==========
    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const h = Math.floor(totalSec / 3600).toString().padStart(2, '0');
      const m = Math.floor((totalSec % 3600) / 60).toString().padStart(2, '0');
      const s = (totalSec % 60).toString().padStart(2, '0');
      return `${h}:${m}:${s}`;
    }

    function formatLapTime(ms) {
      const totalSec = ms / 1000;
      const m = Math.floor(totalSec / 60).toString().padStart(2, '0');
      const s = Math.floor(totalSec % 60).toString().padStart(2, '0');
      const dec = Math.floor((totalSec % 1) * 10);
      return `${m}:${s}.${dec}`;
    }

    // ========== CÁLCULO DE DISTANCIA (Haversine) ==========
    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // Radio de la Tierra en metros
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c; // en metros
    }

    // ========== ACTUALIZAR POSICIÓN ==========
    function updatePosition(pos) {
      const { latitude, longitude } = pos.coords;
      marker.setLatLng([latitude, longitude]);
      map.panTo([latitude, longitude]);
      polyline.addLatLng([latitude, longitude]);

      if (lastPosition) {
        const d = distance(lastPosition.latitude, lastPosition.longitude, latitude, longitude);
        totalDistance += d;
        document.getElementById('distance-btn').textContent = `K: ${(totalDistance / 1000).toFixed(2)}`;
      }

      positions.push({
        lat: latitude,
        lng: longitude,
        time: Date.now(),
        dist: totalDistance
      });
      // ===== MEDICIÓN EN TIEMPO REAL (si está activa) =====
      if (measureMode && measureStartPos) {
        const currentPos = pos.coords;
        measureDistance = distance(
          measureStartPos.latitude,
          measureStartPos.longitude,
          currentPos.latitude,
          currentPos.longitude
        );
        document.getElementById('measure-display').textContent = `${Math.round(measureDistance)} m`;
      }
      lastPosition = { latitude, longitude };

      // Calcular velocidad y ritmo
      if (isRunning && positions.length > 1) {
        const last = positions[positions.length - 1];
        const prev = positions[positions.length - 2];
        const dt = (last.time - prev.time) / 1000; // segundos
        const dd = (last.dist - prev.dist) / 1000; // km
        if (dt > 0) {
          const speedKmh = (dd / dt) * 3600;
          document.getElementById('speed-btn').textContent = `V: ${speedKmh.toFixed(1)}`;
          if (speedKmh > 0) {
            const pace = 60 / speedKmh; // min/km
            const paceMin = Math.floor(pace);
            const paceSec = Math.floor((pace - paceMin) * 60);
            document.getElementById('pace-btn').textContent = `R: ${paceMin}:${paceSec.toString().padStart(2, '0')}`;
          }
        }
      }
    }

    // ========== DESCARGAR TXT ==========
    function downloadTxt() {
      let content = "Cronómetro de Ruta\n==================\n\n";
      content += `Distancia total: ${(totalDistance / 1000).toFixed(3)} km\n`;
      content += `Tiempo total: ${formatTime(Date.now() - startTime)}\n\n`;
      content += "Laps:\n";
      laps.forEach((lap, i) => {
        content += `Lap ${i + 1}: ${formatLapTime(lap.duration)}\n`;
      });
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ruta_cronometro.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ========== CONFIGURAR BOTONES ==========
    document.getElementById('start-btn').addEventListener('click', () => {
      if (!isRunning) {
        // Iniciar
        isRunning = true;
        startTime = Date.now();
        lapStartTime = startTime;

        // Marcar inicio en el mapa
        if (!hasMarkedStart) {
          const startLatLng = marker.getLatLng();
          L.marker(startLatLng, { title: 'Inicio' })
            .addTo(map)
            .bindTooltip('Inicio', { permanent: true, direction: 'top' })
            .openTooltip();
          hasMarkedStart = true;
        }

        document.getElementById('start-btn').textContent = 'Lap';
        mainTimerInterval = setInterval(() => {
          document.getElementById('main-timer').textContent = formatTime(Date.now() - startTime);
        }, 1000);
        lapTimerInterval = setInterval(() => {
          if (isRunning) {
            document.getElementById('lap-timer').textContent = formatLapTime(Date.now() - lapStartTime);
          }
        }, 100);
      } else {
        // Registrar Lap
        const lapTime = Date.now() - lapStartTime;
        laps.push({ duration: lapTime });
        beep();

        // Marcar en el mapa
        const latlng = marker.getLatLng();
        L.marker(latlng, { title: `Lap ${laps.length}` })
          .addTo(map)
          .bindTooltip(`Lap ${laps.length}`, { permanent: true, direction: 'top' })
          .openTooltip();

        // Reiniciar lap timer
        lapStartTime = Date.now();
        document.getElementById('lap-timer').textContent = '00:00.0';
      }
    });

    document.getElementById('stop-btn').addEventListener('click', () => {
      if (isRunning) {
        // Detener
        isRunning = false;
        clearInterval(mainTimerInterval);
        clearInterval(lapTimerInterval);
        if (watchId) navigator.geolocation.clearWatch(watchId);
        // Marcar Fin en el mapa
        const endLatLng = marker.getLatLng();
        L.marker(endLatLng, { title: 'Fin' })
          .addTo(map)
          .bindTooltip('Fin', { permanent: true, direction: 'top' })
          .openTooltip();

        document.getElementById('stop-btn').textContent = 'Guardar';
      } else {
        // Guardar
        downloadTxt();
        // Reiniciar interfaz (opcional)
        location.reload();
      }
    });

    // ========== BOTÓN MEDIR ==========
    document.getElementById('measure-btn').addEventListener('click', () => {
      if (!lastPosition) {
        alert("Espera a que se cargue tu ubicación primero.");
        return;
      }

      if (!measureMode) {
        // Iniciar medición
        measureMode = true;
        measureStartPos = lastPosition;
        measureDistance = 0;
        document.getElementById('measure-btn').textContent = "Finalizar";
        document.getElementById('measure-display').textContent = "0 m";
      } else {
        // Finalizar medición
        // Dentro del else (cuando se finaliza)
        const endPos = lastPosition;
        L.polyline([measureStartPos, endPos], { color: 'green', weight: 3 }).addTo(map);
        measureMode = false;
        measureStartPos = null;
        document.getElementById('measure-btn').textContent = "Medir";
        // Opcional: mantener la última distancia mostrada o resetear
        // Aquí la dejamos fija como valor final
      }
    });    

    // ========== INICIAR GEOLOCALIZACIÓN ==========
    function startTracking() {
      if (!navigator.geolocation) {
        alert("Geolocalización no soportada.");
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          initMap(pos.coords.latitude, pos.coords.longitude);
          watchId = navigator.geolocation.watchPosition(updatePosition, (err) => {
            console.error("Error de geolocalización:", err);
            alert("Error al obtener la ubicación.");
          }, { enableHighAccuracy: true, maximumAge: 10000, timeout: 10000 });
        },
        (err) => {
          console.error("Error inicial:", err);
          alert("No se pudo obtener la ubicación inicial.");
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    // Iniciar al cargar
    window.addEventListener('load', startTracking);
  </script>
</body>
</html>